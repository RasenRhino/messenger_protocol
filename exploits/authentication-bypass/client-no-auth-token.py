#!/usr/bin/env python3
"""
CLIENT
"""

import argparse
import base64
import getpass
import json
import logging
import os
import socket
import sys
import threading
import time
import hashlib
from cryptography.hazmat.primitives.padding import PKCS7
from dotenv import load_dotenv
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.hmac import HMAC
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from argon2 import PasswordHasher
from argon2.exceptions import VerifyMismatchError
from prompt_toolkit import PromptSession
from prompt_toolkit.completion import WordCompleter
from prompt_toolkit.styles import Style

from direct_messenger import DirectMessenger

load_dotenv()

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('SecureMessengerClient')

COMMANDS = ['list', 'send', 'exit', 'help']

PROMPT_STYLE = Style.from_dict({
    'prompt': '#00aa00 bold',
    'username': '#0000aa bold',
})

class SecureMessengerClient:
    """Client component for the Secure Messenger."""
    
    def __init__(self, server_host='localhost', server_port=8000, config_file=None):
        self.server_host = server_host
        self.server_port = server_port
        self.socket = None
        self.connected = False
        self.authenticated = False
        self.username = None
        self.private_key = None
        self.password = None
        self.master_key = None
        self.auth_key = None
        self.online_users = []
        
        self.session_keys = {} # Maps usernames to session keys
        
        self.direct_messenger = None

        self.key_exchange_events = {} 
        
        if config_file:
            self.load_config(config_file)
        
        self.session = PromptSession(
            style=PROMPT_STYLE,
            completer=WordCompleter(COMMANDS)
        )
        
        self.receiving = False
        self.receiver_thread = None
        
    def load_config(self, config_file):
        """Load configuration from a file."""
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
                self.server_host = config.get('server_host', self.server_host)
                self.server_port = config.get('server_port', self.server_port)
                
            logger.info(f"Loaded configuration from {config_file}")
        except Exception as e:
            logger.error(f"Error loading configuration: {e}")
            
    def connect(self):
        """Connect to the server."""
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.connect((self.server_host, self.server_port))
            self.connected = True
            logger.info(f"Connected to server at {self.server_host}:{self.server_port}")
            return True
        except Exception as e:
            logger.error(f"Error connecting to server: {e}")
            return False
            
    def start_receiver(self):
        """Start the message receiver thread."""
        self.receiving = True
        self.receiver_thread = threading.Thread(target=self.message_receiver)
        self.receiver_thread.daemon = True
        self.receiver_thread.start()
        
    def message_receiver(self):
        """Receive and process messages from the server."""
        # Keep track of message IDs to avoid processing duplicates
        processed_messages = set()
        
        while self.receiving and self.connected:
            try:
                self.socket.settimeout(1.0)
                
                try:
                    data = self.socket.recv(4096)
                    self.socket.settimeout(None)
                    
                    if not data:
                        time.sleep(0.5)
                        continue
                    
                    try:
                        message = json.loads(data.decode())
                        
                        # Create a unique identifier for this message
                        # Use sender, recipient, and message content to identify unique messages
                        if message.get('command') == 'message' or message.get('status') == 'message':
                            message_id = f"{message.get('sender')}:{message.get('recipient')}:{message.get('ciphertext')}"
                            
                            # Only process if we haven't seen this message before
                            if message_id not in processed_messages:
                                print(f"\n[RECV] *** CHAT MESSAGE from {message.get('sender')} ***")
                                processed_messages.add(message_id)
                                self.process_message(message)
                        else:
                            self.process_message(message)
                            
                    except json.JSONDecodeError as e:
                        logger.error(f"Invalid JSON: {e}")
                except socket.timeout:
                    continue
                except ConnectionResetError:
                    self.connected = False
                    break
                except OSError as e:
                    if not self.receiving:
                        break
                    if "Bad file descriptor" in str(e):
                        self.connected = False
                        break
                    time.sleep(0.5)
                    continue
                    
            except Exception as e:
                if not self.receiving:
                    break
                time.sleep(1.0)
        
    def test_messaging(self, recipient):
        """Send a test message to validate the messaging system."""
        
        # Ensure we have a session key
        if recipient not in self.session_keys:
            self.session_keys[recipient] = os.urandom(32)
        
        test_message = "This is a test message"
        
        if not self.direct_messenger:
            self.direct_messenger = DirectMessenger(
                self.socket,
                self.username,
                self.session_keys
            )
            self.direct_messenger.register_message_callback(self.on_message_received)
        
        success = self.direct_messenger.send_message(recipient, test_message)
        
        return success
    
    def process_message(self, message):
        """Process a message from the server."""
        if not message:
            return
            
        status = message.get('status')
        command = message.get('command')
        
        
        if status == 'key_exchange_request':
            # Handle key exchange request
            sender = message.get('sender')
            print(f"\nKey exchange request from {sender}")
            self.handle_key_exchange_request(sender)
        elif status == 'key_exchange':
            # Handle key exchange response
            sender = message.get('sender')
            ephemeral_public_key = message.get('ephemeral_public_key')
            self.complete_key_exchange(sender, ephemeral_public_key)
        elif status == 'success' and 'ephemeral_public_key' in message:
            # Handle key exchange success response
            sender = message.get('sender')
            ephemeral_public_key = message.get('ephemeral_public_key')
            self.complete_key_exchange(sender, ephemeral_public_key)
        elif status == 'message' or command == 'message':
            # Forward to direct messenger for handling
            if self.direct_messenger:
                self.direct_messenger.process_message(message)
                
    def on_message_received(self, sender, message):
        """Callback for when a message is received."""
        print(f"\n[{sender}] {message}")
        
        sys.stdout.write(f"{self.username}> ")
        sys.stdout.flush()

    
                
    def register(self, username, password):
        """Register a new user with simplified authentication."""
        if not self.connected:
            logger.error("Not connected to server")
            return False
            
        try:
            # Generate key pair
            private_key = ec.generate_private_key(ec.SECP256R1())
            public_key = private_key.public_key()
            
            # Serialize the public key
            public_key_pem = public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            ).decode()
            
            # Serialize the private key
            private_key_bytes = private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption()
            )
            
            salt = os.urandom(16)
            
            password_hash = hashlib.sha256((password + base64.b64encode(salt).decode()).encode()).hexdigest()
            
            master_key = hashlib.sha256((password + base64.b64encode(salt).decode()).encode()).digest()
            
            aes_key = master_key[:32] # Use first 32 bytes as AES key
            iv = os.urandom(16)
            cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv))
            encryptor = cipher.encryptor()
            
            # PKCS7 padding
            padder = PKCS7(algorithms.AES.block_size).padder()
            padded_data = padder.update(private_key_bytes) + padder.finalize()
            
            encrypted_private_key = encryptor.update(padded_data) + encryptor.finalize()
            encrypted_private_key_with_iv = iv + encrypted_private_key
            
            request = {
                'command': 'simplified_register',
                'username': username,
                'password_hash': password_hash,
                'encrypted_private_key': base64.b64encode(encrypted_private_key_with_iv).decode(),
                'public_key': public_key_pem,
                'salt': base64.b64encode(salt).decode()
            }
            
            self.socket.send(json.dumps(request).encode())
            
            response = json.loads(self.socket.recv(4096).decode())
            
            if response.get('status') == 'success':
                logger.info("Registration successful")
                return True
            else:
                logger.error(f"Registration failed: {response.get('message')}")
                return False
                
        except Exception as e:
            logger.error(f"Error during registration: {e}")
            return False
            
    def login(self, username, password):
        """Login to the server with simplified authentication."""
        if not self.connected:
            logger.error("Not connected to server")
            return False
            
        self.username = username
        self.password = password
        
        try:
            request = {
                'command': 'get_salt',
                'username': username
            }
            print(f"Sending get_salt request: {request}")
            self.socket.send(json.dumps(request).encode())
            
            self.socket.settimeout(5.0)
            data = self.socket.recv(4096)
            print(f"Received data length: {len(data) if data else 0}")
            if not data:
                logger.error("Empty response received when requesting salt")
                return False
                
            print(f"Received salt response data: {data}")
            salt_response = json.loads(data.decode())
            
            self.socket.settimeout(None)
            
            if salt_response.get('status') != 'success':
                logger.error(f"Failed to get salt: {salt_response.get('message')}")
                return False
                
            salt = base64.b64decode(salt_response.get('salt'))
            
            password_hash = hashlib.sha256((password + base64.b64encode(salt).decode()).encode()).hexdigest()
            
            request = {
                'command': 'simplified_login',
                'username': username,
                'password_hash': password_hash
            }
            self.socket.send(json.dumps(request).encode())
            
            auth_response = json.loads(self.socket.recv(4096).decode())
            
            if auth_response.get('status') != 'success':
                logger.error(f"Authentication failed: {auth_response.get('message')}")
                return False
                
            # Get encrypted private key
            encrypted_private_key_b64 = auth_response.get('encrypted_private_key')
            encrypted_private_key_with_iv = base64.b64decode(encrypted_private_key_b64)
            
            # Extract IV and encrypted data
            iv = encrypted_private_key_with_iv[:16]
            encrypted_private_key = encrypted_private_key_with_iv[16:]
            
            # Generate master key for decryption - must match registration
            master_key = hashlib.sha256((password + base64.b64encode(salt).decode()).encode()).digest()
            
            # Decrypt private key
            aes_key = master_key[:32] # Use first 32 bytes as AES key
            cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv))
            decryptor = cipher.decryptor()
            
            decrypted_data = decryptor.update(encrypted_private_key) + decryptor.finalize()
            
            # PKCS7 unpadding
            unpadder = PKCS7(algorithms.AES.block_size).unpadder()
            private_key_bytes = unpadder.update(decrypted_data) + unpadder.finalize()
            
            self.private_key = serialization.load_pem_private_key(
                private_key_bytes,
                password=None
            )
            
            self.authenticated = True
            logger.info("Authentication successful")
            
            self.direct_messenger = DirectMessenger(
                self.socket,
                self.username,
                self.session_keys
            )
            
            self.direct_messenger.register_message_callback(self.on_message_received)
            
            self.start_receiver()
            
            return True
            
        except Exception as e:
            logger.error(f"Error during authentication: {e}")
            return False
            
    def list_users(self):
        """Get a list of online users."""
        if not self.connected or not self.authenticated:
            logger.error("Not connected or authenticated")
            return []
            
        try:
            print("Requesting online users list...")
            request = {
                'command': 'list'
            }
            self.socket.send(json.dumps(request).encode())
            
            print("Waiting for response from server...")
            self.socket.settimeout(5)
            try:
                data = self.socket.recv(4096)
                if not data:
                    print("Empty response received from server")
                    self.socket.settimeout(None)
                    return []
                    
                print(f"Received response: {data.decode()}")
                response = json.loads(data.decode())
                
                self.socket.settimeout(None)
                
                if response.get('status') != 'success':
                    print(f"Failed to get user list: {response.get('message')}")
                    return []
                    
                self.online_users = response.get('users', [])
                return self.online_users
                
            except socket.timeout:
                print("Timeout waiting for server response")
                return []
            except Exception as e:
                print(f"Error receiving server response: {e}")
                return []
            finally:
                self.socket.settimeout(None)
                
        except Exception as e:
            print(f"Error listing users: {e}")
            return []
            
    def initiate_key_exchange(self, recipient):
        if not self.connected or not self.authenticated:
            logger.error("Not connected or authenticated")
            return False

        try:
            print(f"Initiating key exchange with {recipient}...")
            # Generate ephemeral key pair
            ephemeral_private_key = ec.generate_private_key(ec.SECP256R1())
            ephemeral_public_key = ephemeral_private_key.public_key()
            
            ephemeral_public_key_bytes = ephemeral_public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            )
            
            data_to_sign = f"{self.username}:{recipient}:{ephemeral_public_key_bytes.decode()}".encode()
            signature = self.private_key.sign(
                data_to_sign,
                ec.ECDSA(hashes.SHA256())
            )
            
            request = {
                'command': 'key_exchange',
                'sender': self.username,
                'recipient': recipient,
                'ephemeral_public_key': ephemeral_public_key_bytes.decode(),
                'signature': base64.b64encode(signature).decode()
            }
            
            self.socket.send(json.dumps(request).encode())
            
            # Ensure we have a dictionary for ephemeral keys
            if not hasattr(self, 'ephemeral_private_keys'):
                self.ephemeral_private_keys = {}
            self.ephemeral_private_keys[recipient] = ephemeral_private_key

            # Create an Event for this recipient so we can wait for the key exchange to complete
            self.key_exchange_events[recipient] = threading.Event()
            
            print("Key exchange request sent. Awaiting response from the receiver thread...")
            return True
            
        except Exception as e:
            logger.error(f"Error initiating key exchange: {e}")
            return False


            
    def handle_key_exchange_request(self, sender):
        """Handle a key exchange request from another user."""
        if not self.connected or not self.authenticated:
            logger.error("Not connected or authenticated")
            return False
            
        try:
            # Generate ephemeral key pair
            ephemeral_private_key = ec.generate_private_key(ec.SECP256R1())
            ephemeral_public_key = ephemeral_private_key.public_key()
            
            # Serialize ephemeral public key
            ephemeral_public_key_bytes = ephemeral_public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            )
            
            # Create signature
            data_to_sign = f"{self.username}:{sender}:{ephemeral_public_key_bytes.decode()}".encode()
            signature = self.private_key.sign(
                data_to_sign,
                ec.ECDSA(hashes.SHA256())
            )
            
            request = {
                'command': 'key_exchange',
                'sender': self.username,
                'recipient': sender,
                'ephemeral_public_key': ephemeral_public_key_bytes.decode(),
                'signature': base64.b64encode(signature).decode()
            }
            self.socket.send(json.dumps(request).encode())
            
            self.ephemeral_private_keys = {
                sender: ephemeral_private_key
            }
            
            logger.info(f"Key exchange response sent to {sender}")
            return True
            
        except Exception as e:
            logger.error(f"Error handling key exchange request: {e}")
            return False
            
    def complete_key_exchange(self, sender, ephemeral_public_key_pem):        
        if not self.connected or not self.authenticated:
            return False
            
        try:
            # Load ephemeral public key received from the other client
            ephemeral_public_key = serialization.load_pem_public_key(
                ephemeral_public_key_pem.encode()
            )
            
            # Retrieve our ephemeral private key for this exchange
            ephemeral_private_key = self.ephemeral_private_keys.get(sender)
            
            if not ephemeral_private_key:
                return False
                
            # Compute shared secret and derive session key
            shared_secret = ephemeral_private_key.exchange(ec.ECDH(), ephemeral_public_key)
            hkdf = HKDF(algorithm=hashes.SHA256(), length=32, salt=None, info=b"messaging")
            session_key = hkdf.derive(shared_secret)
            
            self.session_keys[sender] = session_key
            
            if self.direct_messenger:
                self.direct_messenger.session_keys = self.session_keys
            
            del self.ephemeral_private_keys[sender]
            
            logger.info(f"Key exchange completed with {sender}")
            print(f"\nSecure messaging channel established with {sender}")

            if sender in self.key_exchange_events:
                self.key_exchange_events[sender].set()
            
            sys.stdout.write(f"{self.username}> ")
            sys.stdout.flush()
            
            return True
            
        except Exception as e:
            import traceback
            traceback.print_exc()
            return False


    def ensure_direct_messenger(self):
        """Ensure the direct messenger exists and has the latest session keys."""
        if not self.direct_messenger:
            self.direct_messenger = DirectMessenger(
                self.socket,
                self.username,
                self.session_keys
            )
            self.direct_messenger.register_message_callback(self.on_message_received)
        else:
            self.direct_messenger.session_keys = self.session_keys
        
        return self.direct_messenger        
    def send_message(self, recipient, message):
            
        if not self.connected or not self.authenticated:
            return False
                
        # Check if we have a session key for this recipient
        if recipient not in self.session_keys:
            if not self.initiate_key_exchange(recipient):
                return False
                
            # Now wait for the key exchange to complete
            event = self.key_exchange_events.get(recipient)
            if event:
                if not event.wait(timeout=15):
                    return False
            else:
                return False
                
            if recipient not in self.session_keys:
                return False
            
        if not self.direct_messenger:
            self.direct_messenger = DirectMessenger(
                self.socket,
                self.username,
                self.session_keys
            )
            self.direct_messenger.register_message_callback(self.on_message_received)
        else:
            self.direct_messenger.session_keys = self.session_keys

        result = self.direct_messenger.send_message(recipient, message)
        
        if result:
            print(f"Message sent to {recipient}.")
        else:
            print(f"Failed to send message to {recipient}.")
                
        return result


    def decrypt_message(self, sender, ciphertext, tag, nonce):
        """Decrypt a message from another user."""
        if sender not in self.session_keys:
            logger.error(f"No session key for {sender}")
            return None
            
        try:
            session_key = self.session_keys[sender]
            
            ciphertext_bytes = base64.b64decode(ciphertext)
            tag_bytes = base64.b64decode(tag)
            nonce_bytes = base64.b64decode(nonce)
            
            # Decrypt message using AES-GCM
            aesgcm = AESGCM(session_key)
            plaintext = aesgcm.decrypt(nonce_bytes, ciphertext_bytes + tag_bytes, None)
            
            return plaintext.decode()
            
        except Exception as e:
            logger.error(f"Error decrypting message: {e}")
            return None
        
    def update_public_key(self):
        """Send a request to update the stored public key on the server."""
        new_public_key = self.public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        ).decode()
        request = {
            'command': 'update_public_key',
            'username': self.username,
            'public_key': new_public_key
        }
        self.socket.send(json.dumps(request).encode())
        response = json.loads(self.socket.recv(4096).decode())
        if response.get('status') == 'success':
            print("Public key updated successfully on server.")
        else:
            print("Failed to update public key on server:", response.get('message'))

   
    def logout(self):
        """Logout from the server."""
        if not self.connected or not self.authenticated:
            logger.error("Not connected or authenticated")
            return False
            
        try:
            data_to_sign = f"logout:{self.username}".encode()
            signature = self.private_key.sign(
                data_to_sign,
                ec.ECDSA(hashes.SHA256())
            )
            
            request = {
                'command': 'logout',
                'signature': base64.b64encode(signature).decode()
            }
            self.socket.send(json.dumps(request).encode())
            
            self.socket.settimeout(3)
            try:
                data = self.socket.recv(4096)
                if data:
                    response = json.loads(data.decode())
                    if response.get('status') == 'success':
                        logger.info("Logout successful")
                    else:
                        logger.warning(f"Logout response: {response.get('message')}")
            except socket.timeout:
                logger.warning("Timeout waiting for logout response")
            except Exception as e:
                logger.warning(f"Error receiving logout response: {e}")
            finally:
                self.socket.settimeout(None)
            
            self.authenticated = False
            self.receiving = False            
            self.username = None
            self.private_key = None
            self.password = None
            self.master_key = None
            self.auth_key = None
            self.online_users = []
            self.session_keys = {}
            
            return True
                    
        except Exception as e:
            logger.error(f"Error during logout: {e}")
            self.authenticated = False
            self.receiving = False
            return False
                
    def close(self):
        """Close the connection to the server."""
        print("Closing connection...")
        
        # Stop the receiver thread first
        if self.receiving:
            self.receiving = False
            time.sleep(0.5)
        
        if self.authenticated:
            try:
                self.logout()
            except Exception as e:
                logger.error(f"Error during logout: {e}")
        
        if self.connected:
            try:
                self.socket.shutdown(socket.SHUT_RDWR)
            except Exception:
                pass
            
            try:
                self.socket.close()
            except Exception:
                pass
                
            self.connected = False
            logger.info("Connection closed")
        
        print("Goodbye!")
    
    def login(self, username, password):
        if not self.connected:
            print("Not connected to server")
            return False
            
        self.username = username
        self.password = password
        print(f"Printing out entered password: {self.password}")
        
        try:
            request = {
                'command': 'get_salt',
                'username': username
            }
            self.socket.send(json.dumps(request).encode())
            
            self.socket.settimeout(5.0)
            data = self.socket.recv(4096)
            if not data:
                return False
                
            response = json.loads(data.decode())
            self.socket.settimeout(None)
            
            if response.get('status') != 'success':
                print(f"Salt request failed: {response.get('message')}")
                return False
                
            salt = base64.b64decode(response.get('salt'))
            salt_str = base64.b64encode(salt).decode()
            
            # Create simple auth token (just a hash of password and salt)
            auth_token = hashlib.sha256(f"{password}:{salt_str}".encode()).hexdigest()
            
            login_request = {
                'command': 'login',
                'username': username,
                'auth_token': 'server is not checking this'
            }
            self.socket.send(json.dumps(login_request).encode())
            
            self.socket.settimeout(5.0)
            data = self.socket.recv(4096)
            if not data:
                return False
                
            login_response = json.loads(data.decode())
            self.socket.settimeout(None)
            
            if login_response.get('status') != 'success':
                print(f"Login failed: {login_response.get('message')}")
                return False
            
            try:
                # Generate a new key pair for this session
                self.private_key = ec.generate_private_key(ec.SECP256R1())
                self.public_key = self.private_key.public_key()
                self.authenticated = True
                self.update_public_key()
                
                print("Login successful!")
                
                self.direct_messenger = DirectMessenger(
                    self.socket,
                    self.username,
                    self.session_keys
                )
                
                self.direct_messenger.register_message_callback(self.on_message_received)
                
                self.start_receiver()
                
                return True
                
            except Exception as e:
                print(f"Error generating new key pair: {e}")
                import traceback
                traceback.print_exc()
                return False
            
        except Exception as e:
            print(f"Exception during login: {e}")
            import traceback
            traceback.print_exc()
            return False

    def run(self):
        """Run the client interface."""
        print("Secure Messenger Client")
        print("=====================")
        
        if not self.connect():
            print("Failed to connect to server. Exiting.")
            return
            
        choice = input("1. Login\n2. Register\nChoice: ")
        
        if choice == '1':
            username = input("Username: ")
            password = getpass.getpass("Password: ")
            
            if not self.login(username, password):
                print("Login failed. Exiting.")
                self.close()
                return
                
        elif choice == '2':
            username = input("Username: ")
            password = getpass.getpass("Password: ")
            confirm_password = getpass.getpass("Confirm Password: ")
            
            if password != confirm_password:
                print("Passwords do not match. Exiting.")
                self.close()
                return
                
            if not self.register(username, password):
                print("Registration failed. Exiting.")
                self.close()
                return
                
            print("Registration successful! Please restart the client and login with your new credentials.")
            self.close()
            return 
        
        elif command.startswith('test '):
            recipient = command.split(' ')[1]
            self.test_messaging(recipient)
                
        else:
            print("Invalid choice. Exiting.")
            self.close()
            return
            
        print(f"Welcome, {username}!")
        print("Type 'help' for a list of commands.")
        
        while self.connected and self.authenticated:
            try:
                command = self.session.prompt(f"{self.username}> ")
                
                if command == 'exit':
                    print("Logging out and exiting...")
                    break
                elif command == 'help':
                    self.print_help()
                elif command == 'list':
                    print("Fetching online users...")
                    users = self.list_users()
                    if users:
                        print("Online users:")
                        for user in users:
                            print(f"  - {user}")
                    else:
                        print("No users online or failed to fetch user list.")
                elif command.startswith('send '):
                    parts = command.split(' ', 2)
                    if len(parts) < 3:
                        print("Usage: send USER MESSAGE")
                        continue
                        
                    recipient = parts[1]
                    message = parts[2]
                    
                    print(f"Sending message to {recipient}...")
                    
                    if recipient not in self.session_keys:
                        print(f"No secure channel with {recipient}. Initiating key exchange...")
                        if not self.initiate_key_exchange(recipient):
                            print(f"Failed to establish secure channel with {recipient}.")
                            continue
                    
                    if not self.direct_messenger:
                        print("Initializing message handler...")
                        self.direct_messenger = DirectMessenger(
                            self.socket,
                            self.username,
                            self.session_keys
                        )
                        self.direct_messenger.register_message_callback(self.on_message_received)
                    
                    if self.direct_messenger.send_message(recipient, message):
                        print(f"Message sent to {recipient}.")
                    else:
                        print(f"Failed to send message to {recipient}.")
                else:
                    print("Unknown command. Type 'help' for a list of commands.")
                    
            except KeyboardInterrupt:
                print("\nExiting...")
                break
            except Exception as e:
                logger.error(f"Error in command loop: {e}")
                print(f"Error: {e}")
                
        self.close()
        
    def print_help(self):
        """Print the help message."""
        print("Commands:")
        print("  list                 - List online users")
        print("  send USER MESSAGE    - Send a message to a user")
        print("  exit                 - Exit the program")
        print("  help                 - Show this help message")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Secure Messenger Client')
    parser.add_argument('--host', type=str, help='Server host')
    parser.add_argument('--port', type=int, help='Server port')
    parser.add_argument('--config', type=str, help='Config file')
    args = parser.parse_args()
    
    host = args.host or os.getenv('SERVER_HOST', 'localhost')
    port = args.port or int(os.getenv('SERVER_PORT', 8000))
    config = args.config
    
    client = SecureMessengerClient(
        server_host=host,
        server_port=port,
        config_file=config
    )
    client.run()