#!/usr/bin/env -S python3 -u

import argparse
import hashlib
import json
import secrets
import select
import socket
import sys
import time

from cryptography.exceptions import InvalidTag
from cryptography.hazmat.primitives.ciphers.aead import AESGCM


# Client class to log in and then transmit/receive messages
class Client:
    def _init_(self, username, password, serverip, serverport):
        self.username = username
        self.server_address = serverip, serverport
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.buffer_size = 1028
        self.address_book = {}

        self.g = 2
        self.N_hex = (
            "AC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07"
            "FC3192943DB56050A37329CBB4A099ED8193E0757767A13D"
            "D52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0"
            "CF6096F0C0B857F689962856DED4010ABD0BE621C3A3960A"
            "54E710C3541B9A4291730E9D55A29E6F3E4AE07F6B0F8FF4"
            "48E3C1B667F0DAD1E02D7C8705B8A3BF8A3171F5"
        )
        self.N = int(self.N_hex, 16)
        self.a = None
        self.A = None
        self.password = password
        self.session_key = None
        self.session_status = 0
        self.mutual_auth = 0
        self.challenge_1 = None

    # Log in as the specified user
    def run(self):
        self.login_request_1()

        # Select tool to manage two input vectors
        while True:
            read_fds = [sys.stdin, self.sock]
            write_fds = []
            ex_fds = []
            timeout = 0.1
            readable, _, _ = select.select(read_fds, write_fds, ex_fds, timeout)

            for fd in readable:
                # Read from the socket (a message)
                if fd == self.sock:
                    message, address = self.client_read_socket()
                    self.handle_message(message, address)
                # Read from stdin (a user command)
                if fd == sys.stdin:
                    command = sys.stdin.readline()
                    self.handle_command(command)

    # Handle any messages coming in the socket
    def handle_message(self, server_message, address):
        match server_message["request"]:
            case "SIGN-IN-2":
                self.server_address = address
                self.generate_session_3(server_message["salt"], server_message["B"])
            case "SIGN-IN-5":
                self.mutual_auth_6(server_message["challenge_2"])
            case "LIST-RESPONSE":
                self.handle_list_response(server_message["iv"], server_message["body"])
            case "P2P-SESSION-KEY-RESPONSE":
                self.handle_p2p_session_key_response(server_message)
            case "NEW-MESSAGE":
                self.print_new_message(server_message["username"],
                                       server_message["body"],
                                       server_message["iv"],
                                       address)
            case "INFORM-QUIT":
                remove_user = server_message["username"]
                try:
                    del self.address_book[remove_user]
                except KeyError:
                    # Never previously communicated with client, pass
                    pass

    # Begin the login process
    def login_request_1(self):
        message = {"request": "SIGN-IN-1", "username": self.username}

        # Get secret a value
        a = secrets.randbelow(self.N - 1) + 1
        self.a = a

        # Calculate A
        A = pow(self.g, a, self.N)
        self.A = 0
    

        # Send username, A
        message["A"] = 0
        self.client_sender(json.dumps(message).encode("utf-8"), self.server_address)

    # Generate the session for client-server communication
    def generate_session_3(self, salt, B):
        self.session_key = hashlib.sha256(b'').digest()
        self.session_status = 1
        self.mutual_auth_4(B)

    # Begin the mutual authentication process with the server
    def mutual_auth_4(self, B):
        A_bytes = self.A.to_bytes((self.A.bit_length() + 7) // 8, 'big')
        B_bytes = B.to_bytes((B.bit_length() + 7) // 8, 'big')
        challenge_1 = A_bytes + B_bytes + self.session_key
        challenge_1_hash = hashlib.sha256(challenge_1)
        self.challenge_1 = challenge_1_hash
        challenge_1_hash_hex = challenge_1_hash.hexdigest()
        message = {"request": "SIGN-IN-4", "username": self.username, "challenge_1": challenge_1_hash_hex}
        self.client_sender(json.dumps(message).encode("utf-8"), self.server_address)

    # Verify Server challenge
    def mutual_auth_6(self, challenge_2_server):
        # Check challenge 2
        A_bytes = self.A.to_bytes((self.A.bit_length() + 7) // 8, 'big')
        challenge_2 = A_bytes + self.challenge_1.digest() + self.session_key
        challenge_2_hash = hashlib.sha256(challenge_2).hexdigest()
        if challenge_2_hash != challenge_2_server:
            self.session_status = 0
            self.session_key = None
            self.challenge_1 = None
            return

        # If successful, mutual authentication is complete
        self.mutual_auth = 1
        self.challenge_1 = None
        print("+> Mutually authenticated Client Side")
        print("+> Enter command\n+> ", end="")

    # Handle a user command
    def handle_command(self, command):
        user_command = command.split(" ", 1)[0].strip()
        match user_command:
            case "list":
                self.send_list_request()
                print("+> ", end="")
            case "send":
                # Check message body first
                try:
                    body = command.split(" ", 2)[2]
                    body.encode("utf-8")
                    # Send a request to server for a Key to communicate to the other client
                    # Get the peer to peer key
                    # Send the message to the other client using the key
                    # If data is already cached/available and not expired, use that instead
                    self.client_chat_sender(command.split(" ", 2)[1], command.split(" ", 2)[2])
                except UnicodeDecodeError:
                    print("-> Message cannot be sent")
                    print("+> ", end="")
            case "q":
                message = {"username": self.username, "request": "QUIT"}
                self.client_sender(json.dumps(message).encode("utf-8"), self.server_address)
                sys.exit(0)
            case _:
                print("-> Invalid command")
                print("+> ", end="")

    # Send a list request to the server
    def send_list_request(self):
        # Send request
        message = {"username": self.username, "request": "LIST"}
        self.client_sender(json.dumps(message).encode("utf-8"), self.server_address)
        message, address = self.client_read_socket()
        self.handle_message(message, address)

    # Handle list response and present it to the user
    def handle_list_response(self, iv, body):
        # Decrypt ciphertext with the symmetric key
        pt = decrypt_ct(self.session_key, bytes.fromhex(iv), bytes.fromhex(body))
        print("<- " + pt)

    # Handle unavailable and successful responses for a session-key request
    def handle_p2p_session_key_response(self, server_response):
        response_code = decrypt_ct(self.session_key,
                                   bytes.fromhex(server_response["iv"]),
                                   bytes.fromhex(server_response["code"]))

        # Code 0 means the user is not logged in
        if response_code == "0":
            response_body = decrypt_ct(self.session_key,
                                       bytes.fromhex(server_response["iv_body"]),
                                       bytes.fromhex(server_response["body"]))
            print("<- " + response_body)
            print("+> ", end="")
        # Log new user information
        else:
            other_client = decrypt_ct(self.session_key,
                                      bytes.fromhex(server_response["iv"]),
                                      bytes.fromhex(server_response["other_client"]))
            peer_key = decrypt_ct_2(self.session_key,
                                    bytes.fromhex(server_response["iv"]),
                                    bytes.fromhex(server_response["peer_key"]))
            expiration = decrypt_ct_2(self.session_key,
                                      bytes.fromhex(server_response["iv"]),
                                      bytes.fromhex(server_response["expiration"]))
            ip = decrypt_ct(self.session_key,
                            bytes.fromhex(server_response["iv"]),
                            bytes.fromhex(server_response["ip"]))
            port = decrypt_ct_2(self.session_key,
                                bytes.fromhex(server_response["iv"]),
                                bytes.fromhex(server_response["port"]))
            self.address_book[other_client] = {"p2p_key": peer_key,
                                               "expiration": int.from_bytes(expiration, 'big'),
                                               "address": (ip, int.from_bytes(port, 'big'))}

            print("+> ", end="")

    # Send a message to another client
    def client_chat_sender(self, destination_client, message_to_send):
        # Check if the destination client data is cached
        user_list = list(self.address_book.keys())
        if destination_client in user_list:
            if time.time() < self.address_book[destination_client]["expiration"]:
                message_body, iv = encrypt_pt(self.address_book[destination_client]["p2p_key"], message_to_send)
                message = {"username": self.username, "request": "NEW-MESSAGE",
                           "body": message_body.hex(), "iv": iv.hex()}
                self.client_sender(json.dumps(message).encode("utf-8"), self.address_book[destination_client]["address"])
                return
            else:
                self.address_book[destination_client]["p2p_key"] = None
                self.address_book[destination_client]["expiration"] = None
                self.address_book[destination_client]["address"] = None

        # Request a session key from the server
        ciphertext, iv = encrypt_pt(self.session_key, destination_client)
        request = {"username": self.username, "request": "P2P-SESSION-KEY",
                   "destination": ciphertext.hex(), "iv": iv.hex()}
        self.client_sender(json.dumps(request).encode("utf-8"), self.server_address)
        message, address = self.client_read_socket()
        self.handle_message(message, address)

        # Send the message
        response_code = decrypt_ct(self.session_key,
                                   bytes.fromhex(message["iv"]),
                                   bytes.fromhex(message["code"]))
        if response_code == "1":
            message_body, iv = encrypt_pt(self.address_book[destination_client]["p2p_key"], message_to_send)
            message = {"username": self.username, "request": "NEW-MESSAGE", "body": message_body.hex(), "iv": iv.hex()}
            self.client_sender(json.dumps(message).encode("utf-8"), self.address_book[destination_client]["address"])

    # Print a new/incoming message from another client
    def print_new_message(self, username, body, iv, address):
        message = decrypt_ct(self.address_book[username]["p2p_key"], bytes.fromhex(iv), bytes.fromhex(body))
        output_message = ("\n<– <From " + address[0] + ":" + str(address[1]) + ":" +
                          username + ">: " + message)
        print(output_message.strip() + "\n+> ", end="")

    # Send given message to given address
    def client_sender(self, message, destination):
        self.sock.sendto(message, destination)

    # Read from the socket in a loop
    def client_read_socket(self):
        server_packet = self.sock.recvfrom(self.buffer_size)
        server_message = server_packet[0].decode("utf-8")
        server_message = json.loads(server_message)
        return server_message, server_packet[1]


# Encrypt with session key
def encrypt_pt(key, pt):
    aes_gcm = AESGCM(key)
    iv = secrets.token_bytes(12)
    authenticate_pw = b"Authenticate CY 4740"
    ciphertext = aes_gcm.encrypt(iv, pt.encode(), authenticate_pw)
    return ciphertext, iv


# Decrypt with given key
def decrypt_ct(key, iv, ct):
    try:
        aes_gcm = AESGCM(key)
        authenticate_pw = b"Authenticate CY 4740"
        pt = aes_gcm.decrypt(iv, ct, authenticate_pw).decode()
        return pt
    except InvalidTag as e:
        print("Decryption failure")
        exit(1)


# Decrypt with given key, data must be decoded after
def decrypt_ct_2(key, iv, ct):
    try:
        aes_gcm = AESGCM(key)
        authenticate_pw = b"Authenticate CY 4740"
        pt = aes_gcm.decrypt(iv, ct, authenticate_pw)
        return pt
    except InvalidTag as e:
        print("Decryption failure")
        exit(1)


# Parse command line arguments to obtain login info, server ip, and server port
def argument_parse():
    parser = argparse.ArgumentParser(description='Chat Client')
    parser.add_argument('-u', '--username', type=str, help="Client Username")
    parser.add_argument('-pw', '--password', type=str, help="Client Password")
    parser.add_argument('-sip', '--serverip', type=str, help="Server IP Address")
    parser.add_argument('-sp', '--serverport', type=int, help="Server Port")
    args = parser.parse_args()
    return args


# Main Function
def main():
    # command_args = argument_parse()
    # client = Client(command_args.username, command_args.password, command_args.serverip, command_args.serverport)
    client = Client('Chris','','127.0.0.1',8000)
    client.run()


# Initiate program
if __name__ == "__main__":
    main()